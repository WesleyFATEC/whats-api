const express = require('express');
const bodyParser = require('body-parser');
const path = require('path');
const whatsapp = require('../whatsapp/client');
const cors = require('cors');
const fs = require('fs').promises;
const multer = require('multer');
const upload = multer({ storage: multer.memoryStorage() });
const ffmpeg = require('fluent-ffmpeg');
const streamifier = require('streamifier');
const { Server } = require('socket.io');
const http = require('http');

const app = express();
const port = 3001;
const server = http.createServer(app);
const io = new Server(server, {
  cors: { origin: 'http://localhost:5173', methods: ['GET', 'POST'] },
});

// Resolver e normalizar caminho de cache para evitar problemas no WSL
const MEDIA_CACHE_PATH = path.normalize(path.resolve(__dirname, 'tmp', 'wa-media'));

// Middleware
app.use(cors({
  origin: 'http://localhost:5173',
  methods: ['GET', 'POST', 'OPTIONS'],
  allowedHeaders: ['Content-Type'],
}));
app.use(bodyParser.json({ limit: '50mb' }));
app.use(bodyParser.urlencoded({ extended: true, limit: '50mb' }));
app.use(express.static(path.join(__dirname, '../../public')));

// Criar diretório de cache na inicialização
async function ensureCacheDirectory() {
  try {
    await fs.mkdir(MEDIA_CACHE_PATH, { recursive: true });
    console.log(`Diretório de cache criado/acessado: ${MEDIA_CACHE_PATH}`);
  } catch (error) {
    console.error(`Erro ao criar diretório de cache ${MEDIA_CACHE_PATH}: ${error.message}`, error.stack);
  }
}
ensureCacheDirectory();

// Configurar listener de mensagens do WhatsApp
whatsapp.setupMessageListener((msg) => {
  io.to(msg.from).emit('newMessage', msg);
  io.to(msg.to).emit('newMessage', msg);
});

// Endpoint: Status do cliente WhatsApp
app.get('/api/whatsapp/status', (req, res) => {
  if (whatsapp.isWhatsAppClientReady()) {
    res.json({ status: 'ready', message: 'WhatsApp Client is ready and connected.' });
  } else {
    res.json({ status: 'not_ready', message: 'WhatsApp Client is not ready or disconnected. Please scan QR code.' });
  }
});

// Endpoint: Enviar mensagem de texto
app.post('/api/whatsapp/send-text', async (req, res) => {
  const { to, message } = req.body;
  if (!to || !message) {
    return res.status(400).json({ error: 'Parâmetros "to" e "message" são obrigatórios.' });
  }
  try {
    await whatsapp.sendTextMessage(to, message);
    res.status(200).json({ success: true, message: 'Mensagem de texto enviada com sucesso.' });
  } catch (error) {
    console.error(`Erro ao enviar mensagem de texto para ${to}: ${error.message}`, error.stack);
    res.status(500).json({ error: 'Falha ao enviar mensagem de texto.', details: error.message });
  }
});

// Endpoint: Listar chats
app.get('/api/whatsapp/chats', async (req, res) => {
  try {
    const searchTerm = req.query.search?.toLowerCase();
    const chats = await whatsapp.listChats(searchTerm);
    res.json(chats);
  } catch (error) {
    console.error(`Erro ao buscar chats: ${error.message}`, error.stack);
    res.status(500).json({ error: 'Erro ao buscar chats', details: error.message });
  }
});

// Endpoint: Listar mensagens
app.get('/api/whatsapp/messages', async (req, res) => {
  const { chatId, limit, before } = req.query;
  if (!chatId) {
    return res.status(400).json({ error: 'chatId é obrigatório.' });
  }
  try {
    const messages = await whatsapp.listMessages(chatId, limit ? parseInt(limit) : 20, before);
    res.json(messages);
  } catch (error) {
    console.error(`Erro ao buscar mensagens para chatId ${chatId}: ${error.message}`, error.stack);
    res.status(500).json({ error: 'Erro ao buscar mensagens', details: error.message });
  }
});

// Endpoint: Obter mídia por messageId
app.get('/api/whatsapp/media/:messageId', async (req, res) => {
  const { messageId } = req.params;
  const { chatId } = req.query;
  if (!messageId || !chatId) {
    return res.status(400).json({ error: 'messageId e chatId são obrigatórios.' });
  }
  try {
    const media = await whatsapp.getMediaByMessageId(messageId, chatId);
    res.json(media);
  } catch (error) {
    console.error(`Erro ao baixar mídia para messageId ${messageId}: ${error.message}`, error.stack);
    res.status(500).json({ error: 'Erro ao baixar mídia', details: error.message });
  }
});

// Endpoint: Servir arquivo de mídia
app.get('/api/whatsapp/file/:messageId', async (req, res) => {
  const { messageId } = req.params;
  res.set('Access-Control-Allow-Origin', 'http://localhost:5173');

  if (!messageId) {
    console.error('Missing messageId');
    return res.status(400).send('messageId obrigatório');
  }

  try {
    // Construir e normalizar caminho do arquivo
    const baseFilePath = path.normalize(path.resolve(MEDIA_CACHE_PATH, messageId));

    // Função para encontrar arquivo com extensão
    async function findFileWithExtension(basePath) {
      const exts = [
        '.jpg', '.jpeg', '.png', '.webp', '.mp4', '.webm', '.mov',
        '.mp3', '.ogg', '.wav', '.opus', '.pdf', '.doc', '.docx', '.xls', '.xlsx', ''
      ];
      for (const ext of exts) {
        const file = `${basePath}${ext}`;
        try {
          await fs.access(file);
          return file;
        } catch {
          continue;
        }
      }
      return null;
    }

    // Verificar se o arquivo já existe no cache
    const existingFile = await findFileWithExtension(baseFilePath);
    if (existingFile) {
      const ext = path.extname(existingFile);
      const contentType = {
        '.jpg': 'image/jpeg',
        '.jpeg': 'image/jpeg',
        '.png': 'image/png',
        '.webp': 'image/webp',
        '.mp4': 'video/mp4',
        '.webm': 'video/webm',
        '.mov': 'video/quicktime',
        '.mp3': 'audio/mp3',
        '.ogg': 'audio/ogg',
        '.wav': 'audio/wav',
        '.opus': 'audio/ogg',
        '.pdf': 'application/pdf',
        '.doc': 'application/msword',
        '.docx': 'application/vnd.openxmlformats-officedocument.wordprocessingml.document',
        '.xls': 'application/vnd.ms-excel',
        '.xlsx': 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet',
        '': 'application/octet-stream'
      }[ext] || 'application/octet-stream';
      res.set('Content-Type', contentType);
      console.log(`Servindo arquivo do cache: ${existingFile}`);
      // Validar arquivo antes de enviar
      try {
        await fs.stat(existingFile);
        return res.sendFile(existingFile);
      } catch (statError) {
        console.error(`Arquivo ${existingFile} encontrado, mas stat falhou: ${statError.message}`, statError.stack);
        throw new Error(`Arquivo ${existingFile} não acessível: ${statError.message}`);
      }
    }

    // Obter mensagem e mídia do WhatsApp
    const client = whatsapp.getWhatsAppClient();
    if (!client) {
      console.error('WhatsApp client not initialized');
      return res.status(500).send('Cliente WhatsApp não inicializado');
    }

    const msg = await client.getMessageById(messageId);
    if (!msg || !msg.hasMedia) {
      console.error(`Message not found or no media for messageId: ${messageId}`);
      return res.status(404).send('Mídia não encontrada');
    }

    const media = await msg.downloadMedia();
    if (!media || !media.data) {
      console.error(`Failed to download media for messageId: ${messageId}`);
      return res.status(404).send('Erro ao baixar mídia');
    }

    // Mapear extensão com base no MIME type
    const ext = {
      'image/jpeg': '.jpg',
      'image/png': '.png',
      'image/webp': '.webp',
      'video/mp4': '.mp4',
      'video/webm': '.webm',
      'video/quicktime': '.mov',
      'audio/mp3': '.mp3',
      'audio/ogg': '.ogg',
      'audio/wav': '.wav',
      'audio/opus': '.opus',
      'application/pdf': '.pdf',
      'application/msword': '.doc',
      'application/vnd.openxmlformats-officedocument.wordprocessingml.document': '.docx',
      'application/vnd.ms-excel': '.xls',
      'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet': '.xlsx'
    }[media.mimetype] || '';

    // Salvar arquivo no cache
    const realFilePath = path.normalize(`${baseFilePath}${ext}`);
    await fs.writeFile(realFilePath, Buffer.from(media.data, 'base64'));
    console.log(`Arquivo salvo em: ${realFilePath}`);
    res.set('Content-Type', media.mimetype || 'application/octet-stream');
    // Validar arquivo após escrita
    try {
      await fs.stat(realFilePath);
      return res.sendFile(realFilePath);
    } catch (statError) {
      console.error(`Arquivo ${realFilePath} salvo, mas stat falhou: ${statError.message}`, statError.stack);
      return res.status(500).send(`Erro ao acessar arquivo salvo: ${statError.message}`);
    }
  } catch (e) {
    console.error(`Erro ao buscar/servir mídia para messageId ${messageId}: ${e.message}`, e.stack);
    return res.status(500).send(`Erro ao buscar/servir mídia: ${e.message}`);
  }
});

// Endpoint: Enviar mídia
app.post('/api/whatsapp/send-media', upload.single('file'), async (req, res) => {
  const { to, caption } = req.body;
  const file = req.file;
  if (!to || !file) {
    return res.status(400).json({ error: 'Parâmetros "to" e "file" são obrigatórios.' });
  }
  try {
    let base64Data, filename, mimetype;
    if (file.mimetype === 'audio/webm' || file.originalname.endsWith('.webm')) {
      const oggBuffer = await convertWebmToOggOpusBuffer(file.buffer);
      base64Data = oggBuffer.toString('base64');
      filename = file.originalname.replace(/\.webm$/, '.ogg');
      mimetype = 'audio/ogg';
    } else {
      base64Data = file.buffer.toString('base64');
      filename = file.originalname;
      mimetype = file.mimetype;
    }
    await whatsapp.sendMediaMessage(to, base64Data, filename, caption || '', false, mimetype);
    res.json({ success: true, message: 'Mídia enviada com sucesso.' });
  } catch (error) {
    console.error(`Erro ao enviar mídia para ${to}: ${error.message}`, error.stack);
    res.status(500).json({ error: 'Erro ao enviar mídia.', details: error.message });
  }
});

// Função auxiliar para conversão de áudio
async function convertWebmToOggOpusBuffer(webmBuffer) {
  return new Promise((resolve, reject) => {
    let chunks = [];
    const command = ffmpeg(streamifier.createReadStream(webmBuffer))
      .format('ogg')
      .audioCodec('libopus')
      .on('error', reject)
      .on('end', () => resolve(Buffer.concat(chunks)))
      .pipe();
    command.on('data', (chunk) => chunks.push(chunk));
  });
}

// Iniciar servidor
async function startServer() {
  try {
    await whatsapp.initializeWhatsAppClient();
    server.listen(port, () => {
      console.log(`API de Backend rodando em http://localhost:${port}`);
    });
  } catch (error) {
    console.error(`Erro ao iniciar a aplicação: ${error.message}`, error.stack);
    process.exit(1);
  }
}

startServer();